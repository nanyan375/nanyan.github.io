---
title: Python实现ping工具(一)
date: 2018-12-15 15:41:51
tags: python ping ICMP struct select
---

### 引入

在linux系统里面我们经常会使用ping这个工具来判断服务器的网络状况，它的使用方式如下图所示：
![FaeGnI.png](https://s1.ax1x.com/2018/12/15/FaeGnI.png)
从上图可知，ping以后显示的结果包括：

- 被测试系统主机名和相应 IP 地址
- 返回给当前主机的 ICMP 报文顺序号
- ttl 生存时间和往返时间 rtt（单位是毫秒，即千分之一秒）

下面我们将使用python来实现这样一个工具的查询效果。
<!--more-->

### 原理

ping命令主要涉及到的是ICMP协议。

> ICMP 是（Internet Control Message Protocol）Internet 控制报文协议；它是 TCP/IP 协议族的一个子协议，用于在 IP 主机、路由器之间传递控制消息；ICMP是IP协议不可分割的一部分,ICMP是属于网络层的一个协议。

ping的命令机制是往网络上另一主机系统发送报文消息，系统收到消息以后它会把报文消息原样送回给发送者。以此来测试网络的通畅情况。
![Fan6YT.png](https://s1.ax1x.com/2018/12/15/Fan6YT.png)

其中，发送的请求报文和回应报文格式都是一样的，正如下表所示：
![FanTk6.jpg](https://s1.ax1x.com/2018/12/15/FanTk6.jpg)

- 类型字段:

> - 回显请求报文其中类型为 0，代码为 0。
> - 回显应答报文其中类型为 8，代码为 0。

- 校验和字段：

> 包括数据在内的整个 ICMP 协议数据包的校验和，具体实现方法会在下面详细介绍。

- 标识符字段：

> 用于唯一标识 ICMP 报文，本项目使用程序的进程 id。因为如果同时在两个命令行终端执行 ping 命令的话，每个 ping 命令都会接收到所有的回显应答，所以需要根据标识符来判断回显应答是否应该接收。

- 序号字段：

> ICMP 报文的序号。

- 数据字段：

> 也就是报文，本项目中我们将发送一个固定长度的字符串。

### 主机字节序和网络字节序

在不同 CPU 中，4字节整型数值1在内存空间的保存方式是不同的。4字节整型数值1可用二进制表示如下：

`00000000 00000000 00000000 00000001`

而有些CPU则以倒序保存。

`00000001 00000000 00000000 00000000`

所以，如果发送主机与接收主机CPU字节序不一样则就会出现问题。引申上面的问题，这就涉及到CPU解析数据的方式，其方式有2种：

- 大端序（Big Endian）：高位字节存放到低位地址。

- 小端序（Little Endian）：高位字节存放到高位地址。

查看自己电脑的字节序可以使用：

``` python
$ ipython
>>> import sys
>>> sys.byteorder
```

由于不同CPU字节序不一样，因此，在通过网络传输数据时约定统一方式，这种约定称为网络字节序（Network Byte Order），非常简单——统一为大端序。而intel的主机一般是小端序，所以我们需要进行转换。以一个16位的数字为例：

``` python
>>> n = 0b1010101011111111
>>> bin(n >> 8)  #得到高位的８个位
'0b10101010'
>>> bin((n << 8) & 0xff00)  #得到低位的８位
'0b1111111100000000'
>>> bn = ((n << 8) & 0xff00) | (n >> 8)
>>> bin(bn)
'ob1111111110101010'
```

由此即可完成主机字节序向网络字节序的转换。

### 校验和算法

ICMP 对首部和报文数据一起计算校验和。检验和算法可以分成两步来实现。首先在发送端，有以下三步：

1. 把校验和字段置为0
2. 对需要校验的数据看成以16bit为单位的数字组成，依次进行二进制求和
3. 将上一步的求和结果取反，存入校验和字段

其次在接收端，也有相应的三步：

1. 对需要校验的数据看成以16bit为单位的数字组成，依次进行二进制求和，包括校验和字段
2. 将上一步的求和结果取反
3. 判断最终结果是否为0。如果为0，说明校验和正确。如果不为0，则协议栈会丢掉接收到的数据

从上可以看出，归根到底，校验和算法就是二进制反码求和。由于先取反后相加与先相加后取反，得到的结果是一样的，所以上面的步骤都是先求和后取反。用python实现如下:

```python
def checksum(data):
    n = len(data)
    m = n % 2
    sum = 0  # 将校验和初始化为0
    # 以16bit为单位，依次进行求和
    for i in range(0, n-m, 2):
        sum += data[i] + (data[i+1] << 8)

    if m:
        sum += data[-1]

    # 对校验和本身进行16bit求和
    sum = (sum >> 16) + (sum & 0xffff)
    sum += sum >> 16  # 如果还有高于16位的继续求和
    # 对结果求反
    answer = ~sum & 0xffff
    # 主机字节序转网络字节序
    answer = ((answer << 8) & 0xff00) | (answer >> 8)
    return answer
```

下一节内容将继续实现ping命令。
